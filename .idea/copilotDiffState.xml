<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/p2pfileshare/controller/ConnectedPeerController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/p2pfileshare/controller/ConnectedPeerController.java" />
              <option name="originalContent" value="package org.example.p2pfileshare.controller;&#10;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.concurrent.Task;&#10;import javafx.fxml.FXML;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.stage.DirectoryChooser;&#10;import org.example.p2pfileshare.model.PeerInfo;&#10;import org.example.p2pfileshare.network.control.ControlClient;&#10;import org.example.p2pfileshare.service.FileShareService;&#10;import org.example.p2pfileshare.util.AppConfig;&#10;&#10;import java.io.File;&#10;import java.nio.file.Path;&#10;import java.util.List;&#10;&#10;public class ConnectedPeerController {&#10;&#10;    @FXML private Label peerNameLabel;&#10;    @FXML private TableView&lt;Row&gt; fileTable;&#10;    @FXML private TableColumn&lt;Row, String&gt; colName;&#10;    @FXML private TableColumn&lt;Row, String&gt; colRelative;&#10;    @FXML private TableColumn&lt;Row, Long&gt;   colSize;&#10;    @FXML private ProgressBar progress;&#10;    @FXML private Label statusLabel;&#10;&#10;    private final ObservableList&lt;Row&gt; rows = FXCollections.observableArrayList();&#10;&#10;    private PeerInfo peer;&#10;    private ControlClient controlClient;&#10;    private FileShareService fileShareService;&#10;&#10;    public void init(PeerInfo peer, ControlClient controlClient, FileShareService fileShareService) {&#10;        this.peer = peer;&#10;        this.controlClient = controlClient;&#10;        this.fileShareService = fileShareService;&#10;&#10;        peerNameLabel.setText(peer.getName() + &quot; (&quot; + peer.getIp() + &quot;)&quot;);&#10;&#10;        colName.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        colRelative.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;relativePath&quot;));&#10;        colSize.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;size&quot;));&#10;        // Format hiển thị kích thước: KB/MB/GB&#10;        colSize.setCellFactory(col -&gt; new TableCell&lt;Row, Long&gt;() {&#10;            @Override&#10;            protected void updateItem(Long item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(formatSize(item));&#10;                }&#10;            }&#10;        });&#10;        fileTable.setItems(rows);&#10;&#10;        // Thêm context menu chuột phải&#10;        setupContextMenu();&#10;&#10;        // nạp lần đầu&#10;        reload();&#10;    }&#10;&#10;    private void setupContextMenu() {&#10;        ContextMenu contextMenu = new ContextMenu();&#10;&#10;        MenuItem downloadItem = new MenuItem(&quot;Tải xuống&quot;);&#10;        downloadItem.setOnAction(e -&gt; {&#10;            Row selected = fileTable.getSelectionModel().getSelectedItem();&#10;            if (selected != null) {&#10;                downloadFile(selected);&#10;            }&#10;        });&#10;&#10;        contextMenu.getItems().add(downloadItem);&#10;&#10;        // Chỉ hiển thị menu khi có item được chọn&#10;        fileTable.setContextMenu(contextMenu);&#10;&#10;        // Hoặc có thể hiển thị menu chỉ khi chuột phải vào row có dữ liệu&#10;        fileTable.setRowFactory(tv -&gt; {&#10;            TableRow&lt;Row&gt; row = new TableRow&lt;&gt;();&#10;            row.setOnContextMenuRequested(event -&gt; {&#10;                if (!row.isEmpty()) {&#10;                    fileTable.getSelectionModel().select(row.getItem());&#10;                    contextMenu.show(row, event.getScreenX(), event.getScreenY());&#10;                }&#10;            });&#10;            return row;&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    public void onReload() {&#10;        reload();&#10;    }&#10;&#10;    private void reload() {&#10;        statusLabel.setText(&quot;Đang tải danh sách...&quot;);&#10;        Task&lt;List&lt;ControlClient.RemoteFile&gt;&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected List&lt;ControlClient.RemoteFile&gt; call() {&#10;                return controlClient.listFiles(peer);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            rows.clear();&#10;            for (var rf : task.getValue()) {&#10;                rows.add(new Row(rf.name, rf.relativePath, rf.size));&#10;            }&#10;            statusLabel.setText(&quot;Đã nạp &quot; + rows.size() + &quot; file&quot;);&#10;        });&#10;        task.setOnFailed(e -&gt; statusLabel.setText(&quot;Lỗi tải danh sách&quot;));&#10;&#10;        new Thread(task, &quot;reload-remote-files&quot;).start();&#10;    }&#10;&#10;    @FXML&#10;    private void onDownloadSelected() {&#10;        Row sel = fileTable.getSelectionModel().getSelectedItem();&#10;        if (sel == null) {&#10;            new Alert(Alert.AlertType.INFORMATION, &quot;Hãy chọn 1 file để tải&quot;).showAndWait();&#10;            return;&#10;        }&#10;        downloadFile(sel);&#10;    }&#10;&#10;    private void downloadFile(Row fileRow) {&#10;        // Người dùng chọn THƯ MỤC lưu (nhớ thư mục lần trước)&#10;        DirectoryChooser dirChooser = new DirectoryChooser();&#10;        dirChooser.setTitle(&quot;Chọn thư mục lưu file&quot;);&#10;&#10;        // Load thư mục đã chọn lần trước nếu có&#10;        final String KEY_LAST_DOWNLOAD_DIR = &quot;last_download_dir&quot;;&#10;        String last = AppConfig.load(KEY_LAST_DOWNLOAD_DIR);&#10;        if (last != null) {&#10;            File lastDir = new File(last);&#10;            if (lastDir.isDirectory()) {&#10;                dirChooser.setInitialDirectory(lastDir);&#10;            }&#10;        }&#10;&#10;        File selectedDir = dirChooser.showDialog(peerNameLabel.getScene().getWindow());&#10;&#10;        // Nếu người dùng hủy chọn, không làm gì cả&#10;        if (selectedDir == null) {&#10;            statusLabel.setText(&quot;Đã hủy tải xuống&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lưu lại thư mục vừa chọn để lần sau mở đúng chỗ&#10;        AppConfig.save(KEY_LAST_DOWNLOAD_DIR, selectedDir.getAbsolutePath());&#10;&#10;        // Tạo đường dẫn file đích bên trong thư mục vừa chọn, giữ nguyên tên file gốc&#10;        File selectedFile = new File(selectedDir, fileRow.name);&#10;&#10;        progress.setProgress(0);&#10;        statusLabel.setText(&quot;Đang tải: &quot; + fileRow.name);&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                Path saveTo = selectedFile.toPath();&#10;                return fileShareService.download(peer, fileRow.relativePath, saveTo);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            Boolean result = task.getValue();&#10;            System.out.println(&quot;Task getValue(): &quot; + result);&#10;            boolean ok = (result != null &amp;&amp; result);&#10;            progress.setProgress(ok ? 1.0 : 0.0);&#10;            statusLabel.setText(ok ? &quot;Hoàn tất - Đã lưu tại: &quot; + selectedFile.getAbsolutePath() : &quot;Lỗi tải&quot;);&#10;        });&#10;        task.setOnFailed(e -&gt; {&#10;            progress.setProgress(0);&#10;            statusLabel.setText(&quot;Lỗi tải&quot;);&#10;        });&#10;&#10;        new Thread(task, &quot;download-remote-file&quot;).start();&#10;    }&#10;&#10;&#10;    @FXML&#10;    private void onDisconnect() {&#10;        // chỉ đổi trạng thái UI; logic disconnect nâng cao có thể thêm sau&#10;        statusLabel.setText(&quot;Đã ngắt kết nối&quot;);&#10;        // đóng tab hiện tại&#10;        peerNameLabel.getScene().getWindow();&#10;        // Tab sẽ do RootController tạo và chứa, ở đây controller con không tự đóng.&#10;    }&#10;&#10;    // Row model cho TableView&#10;    public static class Row {&#10;        private final String name;&#10;        private final String relativePath;&#10;        private final long size;&#10;        public Row(String name, String relativePath, long size) {&#10;            this.name = name; this.relativePath = relativePath; this.size = size;&#10;        }&#10;        public String getName() { return name; }&#10;        public String getRelativePath() { return relativePath; }&#10;        public long getSize() { return size; }&#10;    }&#10;&#10;    // Helper: đổi bytes -&gt; KB/MB/GB theo ngưỡng&#10;    private static String formatSize(long bytes) {&#10;        final double KB = 1024.0;&#10;        final double MB = KB * 1024.0;&#10;        final double GB = MB * 1024.0;&#10;        if (bytes &gt;= GB) {&#10;            return String.format(&quot;%.2f GB&quot;, bytes / GB);&#10;        } else if (bytes &gt;= MB) {&#10;            return String.format(&quot;%.2f MB&quot;, bytes / MB);&#10;        } else {&#10;            return String.format(&quot;%.2f KB&quot;, bytes / KB);&#10;        }&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package org.example.p2pfileshare.controller;&#10;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.concurrent.Task;&#10;import javafx.fxml.FXML;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.stage.DirectoryChooser;&#10;import org.example.p2pfileshare.model.PeerInfo;&#10;import org.example.p2pfileshare.network.control.ControlClient;&#10;import org.example.p2pfileshare.service.FileShareService;&#10;import org.example.p2pfileshare.util.AppConfig;&#10;&#10;import java.io.File;&#10;import java.nio.file.Path;&#10;import java.util.List;&#10;&#10;public class ConnectedPeerController {&#10;&#10;    @FXML private Label peerNameLabel;&#10;    @FXML private TableView&lt;Row&gt; fileTable;&#10;    @FXML private TableColumn&lt;Row, String&gt; colName;&#10;    @FXML private TableColumn&lt;Row, String&gt; colRelative;&#10;    @FXML private TableColumn&lt;Row, Long&gt;   colSize;&#10;    @FXML private ProgressBar progress;&#10;    @FXML private Label statusLabel;&#10;&#10;    private final ObservableList&lt;Row&gt; rows = FXCollections.observableArrayList();&#10;&#10;    private PeerInfo peer;&#10;    private ControlClient controlClient;&#10;    private FileShareService fileShareService;&#10;&#10;    public void init(PeerInfo peer, ControlClient controlClient, FileShareService fileShareService) {&#10;        this.peer = peer;&#10;        this.controlClient = controlClient;&#10;        this.fileShareService = fileShareService;&#10;&#10;        peerNameLabel.setText(peer.getName() + &quot; (&quot; + peer.getIp() + &quot;)&quot;);&#10;&#10;        colName.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        colRelative.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;relativePath&quot;));&#10;        colSize.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;size&quot;));&#10;        // Format hiển thị kích thước: KB/MB/GB&#10;        colSize.setCellFactory(col -&gt; new TableCell&lt;Row, Long&gt;() {&#10;            @Override&#10;            protected void updateItem(Long item, boolean empty) {&#10;                super.updateItem(item, empty);&#10;                if (empty || item == null) {&#10;                    setText(null);&#10;                } else {&#10;                    setText(formatSize(item));&#10;                }&#10;            }&#10;        });&#10;        fileTable.setItems(rows);&#10;&#10;        // Thêm context menu chuột phải&#10;        setupContextMenu();&#10;&#10;        // nạp lần đầu&#10;        reload();&#10;    }&#10;&#10;    private void setupContextMenu() {&#10;        ContextMenu contextMenu = new ContextMenu();&#10;&#10;        MenuItem downloadItem = new MenuItem(&quot;Tải xuống&quot;);&#10;        downloadItem.setOnAction(e -&gt; {&#10;            Row selected = fileTable.getSelectionModel().getSelectedItem();&#10;            if (selected != null) {&#10;                downloadFile(selected);&#10;            }&#10;        });&#10;&#10;        contextMenu.getItems().add(downloadItem);&#10;&#10;        // Chỉ hiển thị menu khi có item được chọn&#10;        fileTable.setContextMenu(contextMenu);&#10;&#10;        // Hoặc có thể hiển thị menu chỉ khi chuột phải vào row có dữ liệu&#10;        fileTable.setRowFactory(tv -&gt; {&#10;            TableRow&lt;Row&gt; row = new TableRow&lt;&gt;();&#10;            row.setOnContextMenuRequested(event -&gt; {&#10;                if (!row.isEmpty()) {&#10;                    fileTable.getSelectionModel().select(row.getItem());&#10;                    contextMenu.show(row, event.getScreenX(), event.getScreenY());&#10;                }&#10;            });&#10;            return row;&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    public void onReload() {&#10;        reload();&#10;    }&#10;&#10;    // thay đổi: public để có thể gọi reload từ bên ngoài (PeerTabController)&#10;    public void reload() {&#10;        statusLabel.setText(&quot;Đang tải danh sách...&quot;);&#10;        Task&lt;List&lt;ControlClient.RemoteFile&gt;&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected List&lt;ControlClient.RemoteFile&gt; call() {&#10;                return controlClient.listFiles(peer);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            rows.clear();&#10;            for (var rf : task.getValue()) {&#10;                rows.add(new Row(rf.name, rf.relativePath, rf.size));&#10;            }&#10;            statusLabel.setText(&quot;Đã nạp &quot; + rows.size() + &quot; file&quot;);&#10;        });&#10;        task.setOnFailed(e -&gt; statusLabel.setText(&quot;Lỗi tải danh sách&quot;));&#10;&#10;        new Thread(task, &quot;reload-remote-files&quot;).start();&#10;    }&#10;&#10;    // mới: gọi khi peer remote bị server ngắt kết nối để cập nhật UI tab&#10;    public void onPeerDisconnected() {&#10;        // chạy trên JavaFX thread nếu gọi từ background&#10;        statusLabel.setText(&quot;Peer đã bị ngắt kết nối&quot;);&#10;        progress.setProgress(0);&#10;        // Có thể disable các control nếu muốn&#10;        fileTable.setDisable(true);&#10;    }&#10;&#10;    @FXML&#10;    private void onDownloadSelected() {&#10;        Row sel = fileTable.getSelectionModel().getSelectedItem();&#10;        if (sel == null) {&#10;            new Alert(Alert.AlertType.INFORMATION, &quot;Hãy chọn 1 file để tải&quot;).showAndWait();&#10;            return;&#10;        }&#10;        downloadFile(sel);&#10;    }&#10;&#10;    private void downloadFile(Row fileRow) {&#10;        // Người dùng chọn THƯ MỤC lưu (nhớ thư mục lần trước)&#10;        DirectoryChooser dirChooser = new DirectoryChooser();&#10;        dirChooser.setTitle(&quot;Chọn thư mục lưu file&quot;);&#10;&#10;        // Load thư mục đã chọn lần trước nếu có&#10;        final String KEY_LAST_DOWNLOAD_DIR = &quot;last_download_dir&quot;;&#10;        String last = AppConfig.load(KEY_LAST_DOWNLOAD_DIR);&#10;        if (last != null) {&#10;            File lastDir = new File(last);&#10;            if (lastDir.isDirectory()) {&#10;                dirChooser.setInitialDirectory(lastDir);&#10;            }&#10;        }&#10;&#10;        File selectedDir = dirChooser.showDialog(peerNameLabel.getScene().getWindow());&#10;&#10;        // Nếu người dùng hủy chọn, không làm gì cả&#10;        if (selectedDir == null) {&#10;            statusLabel.setText(&quot;Đã hủy tải xuống&quot;);&#10;            return;&#10;        }&#10;&#10;        // Lưu lại thư mục vừa chọn để lần sau mở đúng chỗ&#10;        AppConfig.save(KEY_LAST_DOWNLOAD_DIR, selectedDir.getAbsolutePath());&#10;&#10;        // Tạo đường dẫn file đích bên trong thư mục vừa chọn, giữ nguyên tên file gốc&#10;        File selectedFile = new File(selectedDir, fileRow.name);&#10;&#10;        progress.setProgress(0);&#10;        statusLabel.setText(&quot;Đang tải: &quot; + fileRow.name);&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                Path saveTo = selectedFile.toPath();&#10;                return fileShareService.download(peer, fileRow.relativePath, saveTo);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            Boolean result = task.getValue();&#10;            System.out.println(&quot;Task getValue(): &quot; + result);&#10;            boolean ok = (result != null &amp;&amp; result);&#10;            progress.setProgress(ok ? 1.0 : 0.0);&#10;            statusLabel.setText(ok ? &quot;Hoàn tất - Đã lưu tại: &quot; + selectedFile.getAbsolutePath() : &quot;Lỗi tải&quot;);&#10;        });&#10;        task.setOnFailed(e -&gt; {&#10;            progress.setProgress(0);&#10;            statusLabel.setText(&quot;Lỗi tải&quot;);&#10;        });&#10;&#10;        new Thread(task, &quot;download-remote-file&quot;).start();&#10;    }&#10;&#10;&#10;    @FXML&#10;    private void onDisconnect() {&#10;        // chỉ đổi trạng thái UI; logic disconnect nâng cao có thể thêm sau&#10;        statusLabel.setText(&quot;Đã ngắt kết nối&quot;);&#10;        // đóng tab hiện tại&#10;        peerNameLabel.getScene().getWindow();&#10;        // Tab sẽ do RootController tạo và chứa, ở đây controller con không tự đóng.&#10;    }&#10;&#10;    // Row model cho TableView&#10;    public static class Row {&#10;        private final String name;&#10;        private final String relativePath;&#10;        private final long size;&#10;        public Row(String name, String relativePath, long size) {&#10;            this.name = name; this.relativePath = relativePath; this.size = size;&#10;        }&#10;        public String getName() { return name; }&#10;        public String getRelativePath() { return relativePath; }&#10;        public long getSize() { return size; }&#10;    }&#10;&#10;    // Helper: đổi bytes -&gt; KB/MB/GB theo ngưỡng&#10;    private static String formatSize(long bytes) {&#10;        final double KB = 1024.0;&#10;        final double MB = KB * 1024.0;&#10;        final double GB = MB * 1024.0;&#10;        if (bytes &gt;= GB) {&#10;            return String.format(&quot;%.2f GB&quot;, bytes / GB);&#10;        } else if (bytes &gt;= MB) {&#10;            return String.format(&quot;%.2f MB&quot;, bytes / MB);&#10;        } else {&#10;            return String.format(&quot;%.2f KB&quot;, bytes / KB);&#10;        }&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/p2pfileshare/controller/PeerTabController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/p2pfileshare/controller/PeerTabController.java" />
              <option name="originalContent" value="package org.example.p2pfileshare.controller;&#10;&#10;import javafx.application.Platform;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.concurrent.Task;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Node;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.scene.layout.AnchorPane;&#10;import org.example.p2pfileshare.model.PeerInfo;&#10;import org.example.p2pfileshare.network.control.ControlClient;&#10;import org.example.p2pfileshare.service.FileShareService;&#10;import org.example.p2pfileshare.service.PeerService;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;public class PeerTabController {&#10;&#10;    private PeerService peerService;&#10;    private FileShareService fileShareService;&#10;    private ControlClient controlClient;&#10;    private Label globalStatusLabel;&#10;    private ConnectedPeerController connectedPeerController;&#10;    @FXML private TableView&lt;PeerInfo&gt; peerTable;&#10;    @FXML private TableColumn&lt;PeerInfo, String&gt; colPeerName;&#10;    @FXML private TableColumn&lt;PeerInfo, String&gt; colPeerIp;&#10;    @FXML private TableColumn&lt;PeerInfo, Number&gt; colPeerPort;&#10;    @FXML private TableColumn&lt;PeerInfo, PeerInfo.ConnectionState&gt; colPeerStatus;&#10;    @FXML private Label peerStatusLabel;&#10;    @FXML private TabPane mainTabPane; // nếu không có trong FXML, có thể set từ RootController&#10;&#10;    @FXML private ProgressBar downloadProgress;&#10;    @FXML private Label downloadStatusLabel;&#10;&#10;    private final ObservableList&lt;PeerInfo&gt; peerList = FXCollections.observableArrayList();&#10;&#10;    public void init(PeerService peerService,&#10;                     FileShareService fileShareService,&#10;                     ControlClient controlClient,&#10;                     Label globalStatusLabel) {&#10;&#10;        this.peerService = peerService;&#10;        this.fileShareService = fileShareService;&#10;        this.controlClient = controlClient;&#10;        this.globalStatusLabel = globalStatusLabel;&#10;&#10;        setupTable();&#10;    }&#10;&#10;    private void setupTable() {&#10;        colPeerName.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        colPeerIp.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;ip&quot;));&#10;        colPeerPort.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;fileServerPort&quot;));&#10;&#10;        // Hiển thị trạng thái kết nối thực tế thay vì &quot;Online&quot;&#10;        colPeerStatus.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;connectionState&quot;));&#10;        colPeerStatus.setCellFactory(column -&gt; new TableCell&lt;PeerInfo, PeerInfo.ConnectionState&gt;() {&#10;            @Override&#10;            protected void updateItem(PeerInfo.ConnectionState state, boolean empty) {&#10;                super.updateItem(state, empty);&#10;                if (empty || state == null) {&#10;                    setText(null);&#10;                    setStyle(&quot;&quot;);&#10;                } else {&#10;                    switch (state) {&#10;                        case NOT_CONNECTED:&#10;                            setText(&quot;Chưa kết nối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #666666;&quot;);&#10;                            break;&#10;                        case PENDING:&#10;                            setText(&quot;Đang kết nối...&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #ff9800; -fx-font-weight: bold;&quot;);&#10;                            break;&#10;                        case CONNECTED:&#10;                            setText(&quot;Đã kết nối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #4caf50; -fx-font-weight: bold;&quot;);&#10;                            break;&#10;                        case REJECTED:&#10;                            setText(&quot;Bị từ chối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #f44336;&quot;);&#10;                            break;&#10;                    }&#10;                }&#10;            }&#10;        });&#10;&#10;        peerTable.setItems(peerList);&#10;    }&#10;&#10;    private void showMsg(String msg) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(&quot;Thông báo&quot;);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(msg);&#10;        alert.showAndWait();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // QUÉT PEER&#10;    // ===================================&#10;    @FXML&#10;    private void onScanPeers() {&#10;&#10;        // snapshot trạng thái TRƯỚC KHI clear&#10;        Map&lt;String, PeerInfo.ConnectionState&gt; prevStates = peerList.stream()&#10;                .collect(Collectors.toMap(&#10;                        PeerInfo::getPeerId,&#10;                        PeerInfo::getConnectionState,&#10;                        (a,b) -&gt; a&#10;                ));&#10;&#10;        peerStatusLabel.setText(&quot;Đang quét...&quot;);&#10;        peerTable.setDisable(true);&#10;&#10;        Task&lt;List&lt;PeerInfo&gt;&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected List&lt;PeerInfo&gt; call() {&#10;                return peerService.scanPeers();&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            List&lt;PeerInfo&gt; scanned = task.getValue();&#10;&#10;            // gán lại state&#10;            for (PeerInfo p : scanned) {&#10;                PeerInfo.ConnectionState prev = prevStates.get(p.getPeerId());&#10;                if (prev == PeerInfo.ConnectionState.CONNECTED) {&#10;                    p.setConnectionState(PeerInfo.ConnectionState.CONNECTED);&#10;                } else {&#10;                    p.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;                }&#10;            }&#10;&#10;            peerList.setAll(scanned);&#10;            peerStatusLabel.setText(&quot;Đã tìm thấy &quot; + scanned.size() + &quot; peer&quot;);&#10;            if (globalStatusLabel != null) globalStatusLabel.setText(&quot;Quét LAN xong&quot;);&#10;            peerTable.setDisable(false);&#10;        });&#10;&#10;        task.setOnFailed(e -&gt; {&#10;            peerStatusLabel.setText(&quot;Lỗi khi quét&quot;);&#10;            peerTable.setDisable(false);&#10;        });&#10;&#10;        new Thread(task).start();&#10;    }&#10;&#10;    // Public helper để gọi từ RootController khi cần refresh&#10;    public void refresh() {&#10;        onScanPeers();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // KẾT NỐI PEER&#10;    // ===================================&#10;    @FXML&#10;    private void onConnectPeer() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;        if (peer == null) {&#10;            show(&quot;Chưa chọn peer!&quot;);&#10;            return;&#10;        }&#10;&#10;        peerStatusLabel.setText(&quot;Đang gửi CONNECT_REQUEST...&quot;);&#10;        peer.setConnectionState(PeerInfo.ConnectionState.PENDING);&#10;        peerTable.refresh();&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                return controlClient.sendConnectRequest(peer);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            boolean ok = task.getValue();&#10;&#10;            if (ok) {&#10;                peer.setConnectionState(PeerInfo.ConnectionState.CONNECTED);&#10;                peerStatusLabel.setText(&quot;Kết nối thành công!&quot;);&#10;                openConnectedTab(peer);&#10;            } else {&#10;                peer.setConnectionState(PeerInfo.ConnectionState.REJECTED);&#10;                peerStatusLabel.setText(&quot;Peer từ chối hoặc không phản hồi&quot;);&#10;            }&#10;            peerTable.refresh();&#10;        });&#10;&#10;        new Thread(task).start();&#10;    }&#10;&#10;    private void openConnectedTab(PeerInfo peer) {&#10;        try {&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/org/example/p2pfileshare/ConnectedPeerTab.fxml&quot;));&#10;            AnchorPane content = loader.load();&#10;&#10;            connectedPeerController = loader.getController();&#10;            connectedPeerController.init(peer, controlClient, fileShareService);&#10;&#10;            Tab tab = new Tab(&quot;Kết nối: &quot; + peer.getName());&#10;            tab.setContent(content);&#10;            tab.setClosable(true);&#10;&#10;            // tìm TabPane từ một control trong scene&#10;            TabPane tabPane = mainTabPane;&#10;            if (tabPane == null) {&#10;                // fallback: tìm TabPane cha của bảng&#10;                Node n = peerTable;&#10;                while (n != null &amp;&amp; !(n instanceof TabPane)) {&#10;                    n = n.getParent();&#10;                }&#10;                if (n instanceof TabPane) tabPane = (TabPane) n;&#10;            }&#10;            if (tabPane != null) {&#10;                tabPane.getTabs().add(tab);&#10;                tabPane.getSelectionModel().select(tab);&#10;            } else {&#10;                new Alert(Alert.AlertType.WARNING, &quot;Không tìm thấy TabPane để mở tab mới&quot;).showAndWait();&#10;            }&#10;&#10;        } catch (IOException ex) {&#10;            new Alert(Alert.AlertType.ERROR, &quot;Lỗi tải UI tab kết nối: &quot; + ex.getMessage()).showAndWait();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onDownloadFile() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;&#10;        // 1) Chưa chọn peer&#10;        if (peer == null) {&#10;            showMsg(&quot;Vui lòng chọn peer trước!&quot;);&#10;            return;&#10;        }&#10;&#10;        // 2) Peer chưa kết nối&#10;        if (peer.getConnectionState() != PeerInfo.ConnectionState.CONNECTED) {&#10;            showMsg(&quot;Bạn phải kết nối với peer trước khi tải file!&quot;);&#10;            return;&#10;        }&#10;&#10;        // ======= DEMO TẢI FILE TEST =======&#10;        String fileName = &quot;test.pdf&quot;;&#10;        Path saveTo = Path.of(&quot;Downloads/&quot; + fileName);&#10;&#10;        downloadProgress.setProgress(0);&#10;        downloadStatusLabel.setText(&quot;Đang tải...&quot;);&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                return fileShareService.download(peer, fileName, saveTo);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            boolean ok = task.getValue();&#10;            downloadProgress.setProgress(ok ? 1.0 : 0.0);&#10;            downloadStatusLabel.setText(ok ? &quot;Hoàn tất!&quot; : &quot;Lỗi tải file!&quot;);&#10;        });&#10;&#10;        task.setOnFailed(e -&gt; {&#10;            downloadProgress.setProgress(0);&#10;            downloadStatusLabel.setText(&quot;Lỗi tải file!&quot;);&#10;            task.getException().printStackTrace();&#10;        });&#10;&#10;        new Thread(task, &quot;peer-download&quot;).start();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // NGẮT KẾT NỐI&#10;    // ===================================&#10;    @FXML&#10;    private void onDisconnectPeer() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;        if (peer == null) {&#10;            show(&quot;Hãy chọn peer trước!&quot;);&#10;            return;&#10;        }&#10;&#10;        peer.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;        peerTable.refresh();&#10;        peerStatusLabel.setText(&quot;Đã ngắt kết nối&quot;);&#10;    }&#10;&#10;    private void show(String msg) {&#10;        new Alert(Alert.AlertType.INFORMATION, msg).showAndWait();&#10;    }&#10;&#10;    // PUBLIC API: gọi khi remote peer bị ngắt (hoặc khi muốn đặt trạng thái peer về &quot;chưa kết nối&quot;)&#10;    public void onRemotePeerDisconnected(String peerId) {&#10;        if (peerId == null || peerId.isBlank()) return;&#10;&#10;        // Cập nhật trên JavaFX thread để tránh lỗi đa luồng&#10;        Platform.runLater(() -&gt; {&#10;            this.connectedPeerController.onReload();&#10;            System.out.println(&quot;Peer tab controoler co chay&quot;);&#10;            boolean updated = false;&#10;            for (PeerInfo p : peerList) {&#10;                if (peerId.equals(p.getPeerId())) {&#10;                    System.out.println(&quot;đang tien hanh doi trang thai&quot;);&#10;&#10;                    p.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;                    updated = true;&#10;                    // cập nhật label trạng thái nếu cần&#10;                    if (peerStatusLabel != null) {&#10;                        peerStatusLabel.setText(&quot;Peer &quot; + p.getName() + &quot; đã bị ngắt kết nối&quot;);&#10;                    }&#10;                    break;&#10;                }&#10;            }&#10;            // Nếu không tìm thấy trong danh sách hiện tại, có thể refresh toàn bộ danh sách&#10;            if (!updated) {&#10;                // Optional: reload toàn bộ peers từ service nếu muốn đồng bộ&#10;                // refresh();&#10;            }&#10;            if (peerTable != null) peerTable.refresh();&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.example.p2pfileshare.controller;&#10;&#10;import javafx.application.Platform;&#10;import javafx.collections.FXCollections;&#10;import javafx.collections.ObservableList;&#10;import javafx.concurrent.Task;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Node;&#10;import javafx.scene.control.*;&#10;import javafx.scene.control.cell.PropertyValueFactory;&#10;import javafx.scene.layout.AnchorPane;&#10;import org.example.p2pfileshare.model.PeerInfo;&#10;import org.example.p2pfileshare.network.control.ControlClient;&#10;import org.example.p2pfileshare.service.FileShareService;&#10;import org.example.p2pfileshare.service.PeerService;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.stream.Collectors;&#10;&#10;public class PeerTabController {&#10;&#10;    private PeerService peerService;&#10;    private FileShareService fileShareService;&#10;    private ControlClient controlClient;&#10;    private Label globalStatusLabel;&#10;&#10;    // map lưu nhiều controller, key = peerId&#10;    private final Map&lt;String, ConnectedPeerController&gt; connectedControllers = new HashMap&lt;&gt;();&#10;&#10;    @FXML private TableView&lt;PeerInfo&gt; peerTable;&#10;    @FXML private TableColumn&lt;PeerInfo, String&gt; colPeerName;&#10;    @FXML private TableColumn&lt;PeerInfo, String&gt; colPeerIp;&#10;    @FXML private TableColumn&lt;PeerInfo, Number&gt; colPeerPort;&#10;    @FXML private TableColumn&lt;PeerInfo, PeerInfo.ConnectionState&gt; colPeerStatus;&#10;    @FXML private Label peerStatusLabel;&#10;    @FXML private TabPane mainTabPane; // nếu không có trong FXML, có thể set từ RootController&#10;&#10;    @FXML private ProgressBar downloadProgress;&#10;    @FXML private Label downloadStatusLabel;&#10;&#10;    private final ObservableList&lt;PeerInfo&gt; peerList = FXCollections.observableArrayList();&#10;&#10;    public void init(PeerService peerService,&#10;                     FileShareService fileShareService,&#10;                     ControlClient controlClient,&#10;                     Label globalStatusLabel) {&#10;&#10;        this.peerService = peerService;&#10;        this.fileShareService = fileShareService;&#10;        this.controlClient = controlClient;&#10;        this.globalStatusLabel = globalStatusLabel;&#10;&#10;        setupTable();&#10;    }&#10;&#10;    private void setupTable() {&#10;        colPeerName.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;name&quot;));&#10;        colPeerIp.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;ip&quot;));&#10;        colPeerPort.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;fileServerPort&quot;));&#10;&#10;        // Hiển thị trạng thái kết nối thực tế thay vì &quot;Online&quot;&#10;        colPeerStatus.setCellValueFactory(new PropertyValueFactory&lt;&gt;(&quot;connectionState&quot;));&#10;        colPeerStatus.setCellFactory(column -&gt; new TableCell&lt;PeerInfo, PeerInfo.ConnectionState&gt;() {&#10;            @Override&#10;            protected void updateItem(PeerInfo.ConnectionState state, boolean empty) {&#10;                super.updateItem(state, empty);&#10;                if (empty || state == null) {&#10;                    setText(null);&#10;                    setStyle(&quot;&quot;);&#10;                } else {&#10;                    switch (state) {&#10;                        case NOT_CONNECTED:&#10;                            setText(&quot;Chưa kết nối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #666666;&quot;);&#10;                            break;&#10;                        case PENDING:&#10;                            setText(&quot;Đang kết nối...&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #ff9800; -fx-font-weight: bold;&quot;);&#10;                            break;&#10;                        case CONNECTED:&#10;                            setText(&quot;Đã kết nối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #4caf50; -fx-font-weight: bold;&quot;);&#10;                            break;&#10;                        case REJECTED:&#10;                            setText(&quot;Bị từ chối&quot;);&#10;                            setStyle(&quot;-fx-text-fill: #f44336;&quot;);&#10;                            break;&#10;                    }&#10;                }&#10;            }&#10;        });&#10;&#10;        peerTable.setItems(peerList);&#10;    }&#10;&#10;    private void showMsg(String msg) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(&quot;Thông báo&quot;);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(msg);&#10;        alert.showAndWait();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // QUÉT PEER&#10;    // ===================================&#10;    @FXML&#10;    private void onScanPeers() {&#10;&#10;        // snapshot trạng thái TRƯỚC KHI clear&#10;        Map&lt;String, PeerInfo.ConnectionState&gt; prevStates = peerList.stream()&#10;                .collect(Collectors.toMap(&#10;                        PeerInfo::getPeerId,&#10;                        PeerInfo::getConnectionState,&#10;                        (a,b) -&gt; a&#10;                ));&#10;&#10;        peerStatusLabel.setText(&quot;Đang quét...&quot;);&#10;        peerTable.setDisable(true);&#10;&#10;        Task&lt;List&lt;PeerInfo&gt;&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected List&lt;PeerInfo&gt; call() {&#10;                return peerService.scanPeers();&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            List&lt;PeerInfo&gt; scanned = task.getValue();&#10;&#10;            // gán lại state&#10;            for (PeerInfo p : scanned) {&#10;                PeerInfo.ConnectionState prev = prevStates.get(p.getPeerId());&#10;                if (prev == PeerInfo.ConnectionState.CONNECTED) {&#10;                    p.setConnectionState(PeerInfo.ConnectionState.CONNECTED);&#10;                } else {&#10;                    p.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;                }&#10;            }&#10;&#10;            peerList.setAll(scanned);&#10;            peerStatusLabel.setText(&quot;Đã tìm thấy &quot; + scanned.size() + &quot; peer&quot;);&#10;            if (globalStatusLabel != null) globalStatusLabel.setText(&quot;Quét LAN xong&quot;);&#10;            peerTable.setDisable(false);&#10;        });&#10;&#10;        task.setOnFailed(e -&gt; {&#10;            peerStatusLabel.setText(&quot;Lỗi khi quét&quot;);&#10;            peerTable.setDisable(false);&#10;        });&#10;&#10;        new Thread(task).start();&#10;    }&#10;&#10;    // Public helper để gọi từ RootController khi cần refresh&#10;    public void refresh() {&#10;        onScanPeers();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // KẾT NỐI PEER&#10;    // ===================================&#10;    @FXML&#10;    private void onConnectPeer() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;        if (peer == null) {&#10;            show(&quot;Chưa chọn peer!&quot;);&#10;            return;&#10;        }&#10;&#10;        peerStatusLabel.setText(&quot;Đang gửi CONNECT_REQUEST...&quot;);&#10;        peer.setConnectionState(PeerInfo.ConnectionState.PENDING);&#10;        peerTable.refresh();&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                return controlClient.sendConnectRequest(peer);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            boolean ok = task.getValue();&#10;&#10;            if (ok) {&#10;                peer.setConnectionState(PeerInfo.ConnectionState.CONNECTED);&#10;                peerStatusLabel.setText(&quot;Kết nối thành công!&quot;);&#10;                openConnectedTab(peer);&#10;            } else {&#10;                peer.setConnectionState(PeerInfo.ConnectionState.REJECTED);&#10;                peerStatusLabel.setText(&quot;Peer từ chối hoặc không phản hồi&quot;);&#10;            }&#10;            peerTable.refresh();&#10;        });&#10;&#10;        new Thread(task).start();&#10;    }&#10;&#10;    private void openConnectedTab(PeerInfo peer) {&#10;        try {&#10;            FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;/org/example/p2pfileshare/ConnectedPeerTab.fxml&quot;));&#10;            AnchorPane content = loader.load();&#10;&#10;            ConnectedPeerController controller = loader.getController();&#10;            controller.init(peer, controlClient, fileShareService);&#10;&#10;            Tab tab = new Tab(&quot;Kết nối: &quot; + peer.getName());&#10;            tab.setContent(content);&#10;            tab.setClosable(true);&#10;&#10;            // đăng ký controller theo peerId để có thể cập nhật sau này&#10;            connectedControllers.put(peer.getPeerId(), controller);&#10;&#10;            // khi tab đóng thì xoá mapping&#10;            tab.setOnClosed(ev -&gt; connectedControllers.remove(peer.getPeerId()));&#10;&#10;            // tìm TabPane từ một control trong scene&#10;            TabPane tabPane = mainTabPane;&#10;            if (tabPane == null) {&#10;                Node n = peerTable;&#10;                while (n != null &amp;&amp; !(n instanceof TabPane)) {&#10;                    n = n.getParent();&#10;                }&#10;                if (n instanceof TabPane) tabPane = (TabPane) n;&#10;            }&#10;            if (tabPane != null) {&#10;                tabPane.getTabs().add(tab);&#10;                tabPane.getSelectionModel().select(tab);&#10;            } else {&#10;                new Alert(Alert.AlertType.WARNING, &quot;Không tìm thấy TabPane để mở tab mới&quot;).showAndWait();&#10;            }&#10;&#10;        } catch (IOException ex) {&#10;            new Alert(Alert.AlertType.ERROR, &quot;Lỗi tải UI tab kết nối: &quot; + ex.getMessage()).showAndWait();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void onDownloadFile() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;&#10;        // 1) Chưa chọn peer&#10;        if (peer == null) {&#10;            showMsg(&quot;Vui lòng chọn peer trước!&quot;);&#10;            return;&#10;        }&#10;&#10;        // 2) Peer chưa kết nối&#10;        if (peer.getConnectionState() != PeerInfo.ConnectionState.CONNECTED) {&#10;            showMsg(&quot;Bạn phải kết nối với peer trước khi tải file!&quot;);&#10;            return;&#10;        }&#10;&#10;        // ======= DEMO TẢI FILE TEST =======&#10;        String fileName = &quot;test.pdf&quot;;&#10;        Path saveTo = Path.of(&quot;Downloads/&quot; + fileName);&#10;&#10;        downloadProgress.setProgress(0);&#10;        downloadStatusLabel.setText(&quot;Đang tải...&quot;);&#10;&#10;        Task&lt;Boolean&gt; task = new Task&lt;&gt;() {&#10;            @Override&#10;            protected Boolean call() {&#10;                return fileShareService.download(peer, fileName, saveTo);&#10;            }&#10;        };&#10;&#10;        task.setOnSucceeded(e -&gt; {&#10;            boolean ok = task.getValue();&#10;            downloadProgress.setProgress(ok ? 1.0 : 0.0);&#10;            downloadStatusLabel.setText(ok ? &quot;Hoàn tất!&quot; : &quot;Lỗi tải file!&quot;);&#10;        });&#10;&#10;        task.setOnFailed(e -&gt; {&#10;            downloadProgress.setProgress(0);&#10;            downloadStatusLabel.setText(&quot;Lỗi tải file!&quot;);&#10;            task.getException().printStackTrace();&#10;        });&#10;&#10;        new Thread(task, &quot;peer-download&quot;).start();&#10;    }&#10;&#10;&#10;    // ===================================&#10;    // NGẮT KẾT NỐI&#10;    // ===================================&#10;    @FXML&#10;    private void onDisconnectPeer() {&#10;        PeerInfo peer = peerTable.getSelectionModel().getSelectedItem();&#10;        if (peer == null) {&#10;            show(&quot;Hãy chọn peer trước!&quot;);&#10;            return;&#10;        }&#10;&#10;        peer.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;        peerTable.refresh();&#10;        peerStatusLabel.setText(&quot;Đã ngắt kết nối&quot;);&#10;    }&#10;&#10;    private void show(String msg) {&#10;        new Alert(Alert.AlertType.INFORMATION, msg).showAndWait();&#10;    }&#10;&#10;    // PUBLIC API: gọi khi remote peer bị ngắt (hoặc khi muốn đặt trạng thái peer về &quot;chưa kết nối&quot;)&#10;    public void onRemotePeerDisconnected(String peerId) {&#10;        if (peerId == null || peerId.isBlank()) return;&#10;&#10;        // Cập nhật trên JavaFX thread để tránh lỗi đa luồng&#10;        Platform.runLater(() -&gt; {&#10;            boolean updated = false;&#10;&#10;            // 1) cập nhật trạng thái trong peer list&#10;            for (PeerInfo p : peerList) {&#10;                if (peerId.equals(p.getPeerId())) {&#10;                    p.setConnectionState(PeerInfo.ConnectionState.NOT_CONNECTED);&#10;                    updated = true;&#10;                    if (peerStatusLabel != null) {&#10;                        peerStatusLabel.setText(&quot;Peer &quot; + p.getName() + &quot; đã bị ngắt kết nối&quot;);&#10;                    }&#10;                    break;&#10;                }&#10;            }&#10;&#10;            // 2) tìm controller của tab tương ứng và gọi method để cập nhật UI tab nếu tab đang mở&#10;            ConnectedPeerController ctrl = connectedControllers.get(peerId);&#10;            if (ctrl != null) {&#10;                ctrl.onPeerDisconnected();&#10;            }&#10;&#10;            // Nếu không tìm thấy controller, không sao — peerList đã được cập nhật&#10;            if (!updated) {&#10;                // Optional: reload toàn bộ peers từ service nếu muốn đồng bộ&#10;                // refresh();&#10;            }&#10;&#10;            if (peerTable != null) peerTable.refresh();&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>